%本函数从图片的顶部到低端，求取最小cost的路径
function [cost, paths]=compute_cost(~, energy, axis)

%     从第一行开始,计算每一个像素点的累积能量和，即cost。像素点的cost定义为从顶部开始，同一seam上像素点的累积能量和的最小值.
% 
%     同时，我们需要返回这条路径。路径上的每个像素点的值只有三种可能：-1,0,以及1，-1表示当前像素点与它的左上角的元素相连，0表示当前像素点
%     与它正上方的元素相连，而1表示当前像素点与它右上方的元素相连。
%     比如，对于一个3*3的矩阵，如果点(2,2)的值为-1, 则表示点(2,2)与点(1,1)相连接。
% 
%     当能量相同的时候,我们规定选取最左边的路径。
%     
%     提示：由于这个函数会被大量使用，如果循环过多的话，会使程序运行速度变慢的.
%           正常情况下，你只会进行一次列循环，而不会对每一行的元素进行循环。
%           假如你现在是对(i,j)号元素求cost，那么(i,j)号元素只可能与(i-1,j-1)、(i-1,j)，或者(i-1,j+1)号元素相连,并且是其中的最小者。
%           为了避免对每一行的元素都进行循环，我们可以进行向量化操作。
%           
%           举例：假设我们的energy = [1, 2, 3; 4, 5, 6]，现在我们需要确定第二行元素[4, 5, 6]分别是和第一行的哪几个元素相连接，那么我们
%           只需要构造一个新的矩阵M = [99, 1, 2;1, 2, 3;2, 3, 99];矩阵M的第一列代表元素4的可能对应的三个元素，即：[无穷大，1，2]；第二列
%           代表元素5可能对应的三个元素，即[1, 2, 3]；第三列代表元素6可能对应的三个元素，即[2, 3, 无穷大]。
%           通过这种方式，我们只需要对矩阵M沿着竖直方向求一次最小值，就可以把第二行所对应的元素全部都求出来了。避免了对每一行的元素进行循环。
% 
%     参数:
%         image: 该函数里面没有使用
%                (留在这是为了和 compute_forward_cost 函数有一个相同的接口)
%         energy: 形状为 (H, W) 的数组
%         axis: 确定沿着哪个轴计算(axis=0为水平方向，axis=1为竖直方向)
% 
%     返回值:
%         cost: 形状为 (H, W) 的数组，保存累积的损失
%         paths: 形状为 (H, W) 的数组，数组元素为 -1, 0
%         或者1。-1表示与左上角元素相连，0表示与正上方元素相连，1表示与右上方元素相连。

    if axis == 0
        energy = energy';
    end

    [H, W] = size(energy);

    cost = zeros(H,W);
    paths = zeros(H,W);

    % 初始化
    cost(1,:) = energy(1,:); %第一行的cost就是它本身
    paths(1,:) = 0;  % 对于第一行，我们并不在意

%   你的代码
    for i = 2:H
        M = [inf, cost(i-1, 1:W-1); cost(i-1, :); cost(i-1, 2:W), inf];
        [min_val, min_idx] = min(M);
        cost(i, :) = energy(i, :) + min_val;
        paths(i, :) = min_idx - 2;
    end
%   你的代码

    if axis == 0
        cost = cost';
        paths = paths';
    end

end